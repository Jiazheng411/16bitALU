module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input cclk,             // configuration clock, AVR ready when high
    output spi_miso,        // AVR SPI MISO
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR SPI Clock
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
    input avr_tx,           // AVR TX (FPGA RX)
    output avr_rx,          // AVR RX (FPGA TX)
    input avr_rx_busy,      // AVR RX buffer full
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8]     // DIP switches on IO Shield
  ) {
  
  sig rst;                  // reset signal
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    .rst(rst){
    
      // declare seven_seg display
      multi_seven_seg seg;
        
      // declare stopper
      dff mistake_stopper;
      dff end_stopper;
      
    }
    
  }
  //mycounter counter(.rst(rst));
  counter counter(#SIZE(5), #DIV(24),  .rst(rst));
  
  alu alu;
  sig testcases[25][7][16];
  sig test_case_index[5];
  sig test_case_alunf[6];
  sig test_case_a[16];
  sig test_case_b[16];
  sig alu_z;
  sig alu_v;
  sig alu_n;
  sig alu_result[16];
  sig correct_z;
  sig correct_v;
  sig correct_n;
  sig correct_result[16];
  
  sig display_hex_low[4];
  sig display_hex_high[4];
  
  
  always {
    counter.clk = clk;
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    led = 8h00;             // turn LEDs off
    spi_miso = bz;          // not using SPI
    spi_channel = bzzzz;    // not using flags
    avr_rx = bz;            // not using serial port
    
    io_led = 3x{{8h00}};    // turn LEDs off
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;           // select no digits
    
    
    testcases = 
      //alunf       a         b      out       z     v     n
    { 
      {16b000000, 16h0002, 16h0002, 16h0004, 16b0, 16b0, 16b0},              //index: 24,11000    2 + 2 = 4
      {16b000000, 16h7fff, 16h0001, 16h8001, 16b0, 16b1, 16b1},              //index: 23,10111    32767 + 1 = -32768, overflow
      {16b000000, 16hfff6, 16h000a, 16h0000, 16b1, 16b0, 16b0},              //index: 22,10110    -10 + 10 = 0
      
      {16b000001, 16h0002, 16h0002, 16h0000, 16b1, 16b0, 16b0},              //index: 21,10101    2 - 2 = 0
      {16b000001, 16h8000, 16h0001, 16h7fff, 16b0, 16b1, 16b0},              //index: 20,10100    -32768 - 1 = 32767, overflow,
      {16b000001, 16h000a, 16h0005, 16h0005, 16b0, 16b0, 16b0},              //index: 19,10011    10 - 5 = 5
      {16b000001, 16hfff6, 16h0005, 16hfff1, 16b0, 16b0, 16b1},              //index: 18,10010    -10 - 5 = -15
      
      {16b000010, 16h000a, 16h000a, 16h0064, 16b0, 16b0, 16b0},              //index: 17,10001    10 * 10 = 100
      {16b000011, 16h000a, 16h0002, 16h0005, 16b0, 16b0, 16b0},              //index: 16,10000    10 / 2 = 5
      {16b000011, 16h000f, 16h0006, 16h0002, 16b0, 16b0, 16b0},              //index: 15,01111    15 / 6 = 2
      {16b000100, 16h000a, 16h0002, 16h0000, 16b0, 16b0, 16b0},              //index: 14,01110    10 % 2 = 0
      {16b000100, 16h000f, 16h0006, 16h0003, 16b0, 16b0, 16b0},              //index: 13,01101    15 % 6 = 3
      
      {16b011000, 16b1010101111000101, 16b1111001101010100, 16b1010001101000100, 16b0, 16b0, 16b0},         //index: 12,01100 and
      {16b011110, 16b1111001101010100, 16b1010101111000101, 16b1111101111010101, 16b0, 16b0, 16b0},         //index: 11,01011 or
      {16b010110, 16b1010101111000101, 16b1111001101010100, 16b0101100010010001, 16b0, 16b0, 16b0},         //index: 10,01010 xor
      {16b011010, 16b1010101111000101, 16b1111001101010100, 16b1010101111000101, 16b0, 16b0, 16b0},         //index: 9,01001  a
      
      {16b110011, 16h0002, 16h0002, 16h0001, 16b1, 16b0, 16b0},              //index: 8,01000    2 == 2
      {16b110011, 16h0003, 16h0002, 16h0000, 16b0, 16b0, 16b0},              //index: 7,00111    3 == 2
      
      {16b110101, 16h8000, 16h0001, 16h0001, 16b0, 16b1, 16b0},              //index: 6,00110    -32768 < 1
      {16b110101, 16h000a, 16h0005, 16h0000, 16b0, 16b0, 16b0},              //index: 5,00101    10 < 5
      
      {16b110111, 16hfffb, 16h0005, 16h0001, 16b0, 16b0, 16b1},              //index: 4,00100   -5 <= 5 
      {16b110111, 16h0002, 16h0002, 16h0001, 16b1, 16b0, 16b0},              //index: 3,00011    2 <= 2
      
      {16b100000, 16hffff, 16h0004, 16hfff0, 16b0, 16b0, 16b0},              //index: 2,00010   shift left
      {16b100001, 16hffff, 16h0004, 16h0fff, 16b0, 16b0, 16b0},              //index: 1,00001   shift right
      {16b100011, 16hf0ff, 16h0004, 16hff0f, 16b0, 16b0, 16b0}               //index: 0,00000   shift right arith
      
    };
    
    test_case_index = counter.value;
    test_case_alunf = testcases[test_case_index][6][5:0];
    test_case_a = testcases[test_case_index][5];
    test_case_b = testcases[test_case_index][4];
    correct_result = testcases[test_case_index][3];
    correct_z = testcases[test_case_index][2][0];
    correct_v = testcases[test_case_index][1][0];
    correct_n = testcases[test_case_index][0][0];
    
    alu.a = test_case_a;
    alu.b = test_case_b;
    alu.alufn = test_case_alunf;
    alu_result = alu.out;
    alu_z = alu.z;
    alu_v = alu.v;
    alu_n = alu.n;
    
    io_led[2][7:0] = alu_result[15:8];
    io_led[1][7:0] = alu_result[7:0];
    io_led[0][7:3] = 5x{(correct_result == alu_result)};
    io_led[0][0] = (correct_z == alu_z);
    io_led[0][1] = (correct_v == alu_v);
    io_led[0][2] = (correct_n == alu_n);
    //io_led[0][4:0] = test_case_index;
    
    display_hex_low = counter.value[3:0];
    display_hex_high = counter.value[4];
    
    seg.values = {4h0, 4h0, display_hex_high, display_hex_low};
     
    io_seg = ~seg.seg;      // connect segments to the driver
    io_sel = ~seg.sel;      // connect digit select to the driver
    
    mistake_stopper.d = ((correct_result != alu_result) | (correct_z != alu_z) | (correct_v != alu_v) | (correct_n != alu_n));
    
    if(io_dip[0][0]){
      if(mistake_stopper.q){
           counter.clk = 0;
      }
    }
    
    end_stopper.d = (counter.value == 5b11000);
    if(end_stopper.q){
      counter.clk = 0;
    }
    
  }
  
}